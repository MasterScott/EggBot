Updated list of todo items for EBB/3BB refactor

NOTES:
  - Current USB stack does not appear to be happy with commands from PC > 64 bytes in length (total)
  - Current USB stack does not appear to be happy with printf() data going back to PC > 64 bytes in length (total)
  - Maybe latest USB stack with XC8 compiler would solve this problem? (probably not worth the effort)
  - For now, just note the limitation and make sure to stay within the 64 byte limits

* Perform RAM analysis, block by block, see where there are holes and map out all usage

* Refactor motion FIFO to re-use values based on command to save RAM and increase size of FIFO

* On driver init, read out OTP bit for internal sense resistor, and program that OTP bit if it's not right.
  - (DONE)

* From EBB issue #139 - make all return values consistent: repeat the command, then optional data, then a carriage return. 
* From EBB issue #139 - make all commands two letters long 
  - (DONE)
* From EBB issue #139 - make all errors follow the above format (two character error code, followed by a fixed length text string describing the error, all semi-human readable)

* Remove <servo_rate_up> and <servo_rate_down> as global SC command parameters
* Added global <gPenMoveDuration> as global SC command parameter (for SP command)
* Remove g_servo2_RPn (hard code to RP4)

* On SC,4 and SC,5 check that Min is always a larger number than Max

* Add IMMEDIATE/FIFO parameter to PO commands (maybe not, based on Windell discussion)

* *BB code needs to boot and run even if USB isn't present at boot. If only 9V is there, still need to execute and run normal loop 
  - (DONE)

* Create simple PC application to hammer *BB with USB commands and measure throughput - use during development to tune changes for maximum command throughput

* To save on RAM, eleminate the last_command[] buffer system (not needed when computers talk to *BB)
  - (DONE)

* Possible optomization - make extract_number() set the ReturnValue to zero on entry so that calling functions don't have to do it. Then go through and elemninate any initalized values on passed in paratmers to the function.

* Make sure you can set the FIFO depth to zero, which requires immediate execution of all commands (even motion control ones)

* Make sure that if you change the FIFO size, and there are items in the FIFO, they do not get deleted. All commands must finish properly.
  - If you have the fifo size set to 10, and you have 10 items in it, then set it to 0, those 10 commands can't get lost.

* Force drivers to be DISABLED until a succecssful register read and subsiquent init, then ENABLE them (to prevent high current draw until we detect that the drivers are powered)
  - Poll the drivers every 100ms looking for the 'reset' bit in GSTAT to be set 
  - Note that we may want to change to using HLVDIN as a true analog watchdog input (with interrupt) on v1.1 3BB version (would require new code) - Windell says not a good plan
  - Need to get OTP bits set such that TMC2209 outputs are disabled on powerup/reset

* Old "A" command now named "RA" (Read Analog)
  - (DONE)

* Make command parsing use a lookup table rather than a huge switch/case
  - (DONE) - didn't save much RAM or ROM, but is much easier to maintain

* Use ADC conversions of SCALED_V+ input every time through main() to determine when to initialize stepper drivers
  - (DONE)

* Perform ADC offset calibration whenever power has been applied to motor drivers
  - (DONE)

* Perform ADC offset calibration at boot (init)
  - (DONE)

* Remove ADC interrupt and automatic sequencing.
  - (DONE) ADC only converts on user command now

* Add internal ADC command to convert any ADC channel in blocking fashion
  - (DONE)

* Convert AC and A commands to use blocking convert
  - (DONE)

* Refactor I/O initialization
  - Make table of all I/O ports for each board, make I/O init smaller

* Should we break out all "pen" functionality (SP, TP) into it's own file? Now that it's all stepper based, doesn't seem to fit in servo.c anymore

* How to handle limping of pen stepper? At same time as others, or different command? Need to re-init to MAX position after turning power back on

* Remove SC commands which allow for external stepper drivers 
  - Remove from SC command 
  - Remove from ISR

* On EBB, RC Servo RB1 will ALWAYS be a pen output. No option to disable it.

* Update all variable names to use common coding standard

* Add section headers to all .c and .h files (defines, includes, variables, prototypes, etc.)

* (3BB) Remove commands that don't make sense anymore, like RC Servo power control

* Remove analog conversions from low ISR, instead, make them simple and blocking
  - (DONE)

* Pull out pulse commands to own files

* Factor out command parsing into its own file
  - Make table based to shorten code?
    - (DONE) didn't shorten code much

* Factor out ISRs into their own file
  - (DONE)

* Create UART I/O low level code in own file
  - (DONE)

* Factor out USB serial I/O into own file

* Factor out motion control commands into own file

* Factor out 'instant' commands into own file

* Factor out FIFO code into own file

* Put all RC Servo stuff into RCServo2.c, then rename to servo.c

* Can the "old" servo stuff be completely removed and just use new RCServo2 code? (yes)

* OK to remove all UBW "T" command and ISR/FIFO? (YES)
  - Done

* Remove QN, SN, NI, ND commands as well
* Remove BO, BS, SS, RS, SI, RI, CI, RC, BC, TX, RX, CX

* Break out command processing into own file (parse.c/h)

* Convert all variable types to "Microchip" standard (UINT8, etc.)

* Make UART receive interrupt based? (try on branch first)

* Create true 'debug' build, and in production build comment out
  - FramingErrorCounter and OverrunErrorCounter and SS command in serial.c
  - Input paramter test function

* Work out which commands can have DelayValues, and how that interacts with the other code in the isr
  - Does SE get a Delay value? If so, how to prevent SE from executing every time through ISR during delay?
    - Convert COMMAND_SE to COMMAND_DELAY after SE command excecuted (in ISR)?


Code Size : RAM/Free, %RAM used, ROM/Free, %ROM used
  EBB_BL
    5/24  : 3461/315, 42794/22734


  3BB_BL 
    5/24  : 3461/315, 42794/22734
    7/6   : 3305/471, 43407/22121
    7/8   : 3271/505, 44213/21315
(switched to free version of C18 compiler's optomizations)
    7/12  : 3213/563, 85%, 58203/7325, 89%
    7/13  : 3207/569, 85%, 57890/7638, 88%
    7/18  : 3207/569, 85%, 58058/7470, 89%
    7/19  : 2973/803, 79%, 57706/7822, 88%  (After FIFO refactor)